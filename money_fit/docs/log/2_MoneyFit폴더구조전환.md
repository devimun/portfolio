<!-- @format -->

# MoneyFit 폴더 구조 전환

## 배경

- MoneyFit은 설정, 홈, 지출, 통계 등 기능이 빠르게 늘어나는 앱으로, 초기에 Layer-first(데이터/도메인/UI) 구조를 택했습니다.
- 기능 단위 유지보수 효율이 떨어지고, 동일 기능을 수정하기 위해 여러 폴더를 넘나드는 피로도가 발생했습니다.

## 대안 비교

| 항목      | Layer-first                                                    | Feature-first                              |
| --------- | -------------------------------------------------------------- | ------------------------------------------ |
| 파일 탐색 | 동일 기능 수정 시 models → repositories → viewmodels 순회 필요 | 기능 폴더 내부에서 대부분 해결했습니다.    |
| 응집도    | 기술 계층 기준으로 분리되어 낮았습니다.                        | 기능 단위로 코드가 모여 높았습니다.        |
| 확장      | 기능 추가 시 여러 계층에 산재했습니다.                         | `features/<new>` 폴더만 증설하면 됐습니다. |

## 재설계 방향

1. **Core vs Feature 구분**
   - `lib/core`: 전역 공통 요소(DB, router, theme, widgets)를 모았습니다.
   - `lib/features`: `auth`, `calendar`, `expense`, `home`, `settings`, `statistics` 등 기능별 디렉터리를 구성했습니다.
2. **폴더 표준 템플릿**
   - 기능 폴더 안에 `view/`, `viewmodel/`, `widgets/`, 필요 시 `model/`을 정의해 일관성을 확보했습니다.
3. **공유 로직 모듈화**
   - 반복되는 위젯/서비스는 core로 승격하고, 나머지는 기능 내부에서 캡슐화했습니다.

## 도입 효과

- **작업 범위가 명확**: 예) 설정 화면 개선 시 `features/settings`만 집중하면 되므로 컨텍스트 전환이 줄었습니다.
- **겹치는 의존성 감소**: feature 간 직접 참조를 줄이고, 필요한 경우 core 서비스나 Provider를 통해 통신하도록 정리했습니다.
- **신규 기능 온보딩**: 캘린더, 통계 등 후속 기능 추가 때 기존 구조를 복제해 빠르게 착수할 수 있었습니다.

## 남은 과제 및 기준

- 기능 간 공유 위젯을 core로 올릴지 여부는 *세 기능 이상이 참조*하는 순간 결정하기로 했습니다.
- 모듈 규모가 커지면 `packages/`로 분리할 수 있도록 디렉터리 명명 규칙과 export barrel을 준비했습니다.

## 회고

- 구조 재편은 단순한 폴더 이동이 아니라 협업 컨벤션과 유지보수 비용을 결정짓는 투자임을 확인했습니다.
- Feature-first는 사이드 프로젝트라도 성장 시 필연적으로 맞이할 스케일 문제를 미리 해결해 준다는 점을 재확인했습니다.
