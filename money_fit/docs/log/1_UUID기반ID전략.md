<!-- @format -->

# UUID 기반 ID 전략

## 배경
- MoneyFit은 로컬 First 전략으로 SQLite를 우선 채택했고, 모든 지출 데이터가 디바이스 내부에서만 순환하던 시점에는 `AUTOINCREMENT`가 가장 단순한 기본 키였습니다.
- 기능 확장 로드맵(동기화, 멀티 디바이스, Supabase 도입)이 확정되면서 "서버가 없는 전제"가 깨졌고, ID 충돌 가능성을 즉시 제거할 필요가 생겼습니다.

## 문제 진단
| 구분 | 설계 | 관찰 결과 |
| --- | --- | --- |
| 초기 스키마 | `INTEGER PRIMARY KEY AUTOINCREMENT` | 사용자 A·B가 동일한 id(1,2,3)를 생성해 서버 병합 시 충돌했습니다. |
| 운영 시나리오 | 오프라인에서 다수 레코드 생성 후 동기화 | 서버가 id 재발급을 맡으면 오프라인 UX가 붕괴하고, 오프셋 전략은 구현/검증 비용이 과도했습니다. |
| 품질 리스크 | 충돌 감지 로직 부재 | 데이터 손실 또는 중복 삽입 가능성이 존재했습니다. |

## 의사결정
1. **충돌 자체를 미연에 방지**: 서버-클라이언트 어느 한쪽에서만 발급하는 방식은 오프라인 전략과 모순되어, 클라이언트가 전 세계적으로 고유한 키를 발급하도록 했습니다.
2. **운영 효율성 최우선**: UUID v4는 128비트 중 122비트를 난수로 채워 2^122(≈5.3×10^36) 개의 조합을 제공하므로 실질적으로 재시도 로직이 필요 없다고 판단했습니다.
3. **확장성 고려**: Supabase/PostgreSQL, Firebase 등 복수 백엔드와 연동 시에도 동일한 키 스킴을 공유할 수 있어야 했기에 텍스트 기반 ID를 채택했습니다.

## 구현
```sql
-- before
table expenses (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  amount REAL NOT NULL
);

-- after
table expenses (
  id TEXT PRIMARY KEY,      -- UUID v4
  user_id TEXT NOT NULL,
  name TEXT NOT NULL,
  amount REAL NOT NULL
);
```
- 클라이언트는 `uuid` 패키지로 ID를 생성하고, 서버는 전달받은 값 그대로 저장/검증하도록 구성했습니다.
- 충돌이 발생하더라도 RDB의 PK 제약이 거부하므로 필요 시 `try-catch`에서 재시도할 수 있지만, 실제 운영에서는 로그 모니터링만으로 충분하다고 판단했습니다.

## 아키텍처 영향
- **인증/데이터 저장**: Supabase Auth + PostgreSQL로 사용자를 식별하고, 모든 서드파티 서비스(Firebase Analytics/AdMob)와 동일한 UID를 공유하도록 했습니다.
- **익명 계정 플로우**: 앱 최초 실행 시 익명 UUID 기반 이메일로 `signUp` 후, 추후 소셜 로그인 전환 시 `updateUser`만 수행해 데이터 연속성을 유지했습니다.
- **추가 서비스 연계**: Firebase Remote Config, Notification 등 외부 서비스와 연동 시에도 사용자/지출 레코드 추적이 일관되도록 설계했습니다.

## 회고 및 메모
- 확률적 충돌을 대비한 방어 코드를 작성하는 대신, 네트워크 오류·데이터 검증과 같이 실제 발생 빈도가 높은 영역에 테스트 리소스를 재배분했습니다.
- 오프라인 전략을 채택한다면 **ID 전략은 의존성(서버 유무)과 무관하게 처음부터 전역 고유성을 보장**하도록 설계해야 함을 재확인했습니다.
